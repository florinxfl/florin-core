// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from libunity.djinni

#pragma once

#include <cstdint>
#include <string>
#include <unordered_map>
#include <vector>

struct ResultRecord;
struct WitnessAccountStatisticsRecord;
struct WitnessEstimateInfoRecord;
struct WitnessFundingResultRecord;

/** C++ interface to control witness accounts */
class IWitnessController {
public:
    virtual ~IWitnessController() {}

    /** Get information on min/max witness periods, weights etc. */
    static std::unordered_map<std::string, std::string> getNetworkLimits();

    /** Get an estimate of weights/parts that a witness account will be funded with */
    static WitnessEstimateInfoRecord getEstimatedWeight(int64_t amount_to_lock, int64_t lock_period_in_blocks);

    /** Fund a witness account */
    static WitnessFundingResultRecord fundWitnessAccount(const std::string & funding_account_UUID, const std::string & witness_account_UUID, int64_t funding_amount, int64_t requestedLockPeriodInBlocks);

    /** Renew a witness account */
    static WitnessFundingResultRecord renewWitnessAccount(const std::string & funding_account_UUID, const std::string & witness_account_UUID);

    /** Get information on account weight and other witness statistics for account */
    static WitnessAccountStatisticsRecord getAccountWitnessStatistics(const std::string & witnessAccountUUID);

    /** Turn compounding on/off */
    static void setAccountCompounding(const std::string & witnessAccountUUID, int32_t percent_to_compount);

    /** Check state of compounding; returns a percentage between 1 and 100, or 0 if not compounding */
    static int32_t isAccountCompounding(const std::string & witnessAccountUUID);

    /** Get the witness address of the account */
    static std::string getWitnessAddress(const std::string & witnessAccountUUID);

    /** Get the optimal distribution amounts for the account; totalNetworkWeight should be the value of "total_weight_eligible_raw" */
    static std::vector<int64_t> getOptimalWitnessDistribution(int64_t amount, int64_t durationInBlocks, int64_t totalNetworkWeight);

    /** Same as the above but calculates all the paramaters from the account UUID; its more efficient to use the other call if you already have these values */
    static std::vector<int64_t> getOptimalWitnessDistributionForAccount(const std::string & witnessAccountUUID);

    /** Redistribute a witness account to its optimal distribution, call 'getOptimalWitnessDistribution' first to calculate this */
    static ResultRecord optimiseWitnessAccount(const std::string & witnessAccountUUID, const std::string & fundingAccountUUID, const std::vector<int64_t> & optimalDistribution);
};
